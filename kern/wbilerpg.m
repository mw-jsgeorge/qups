function [cxy, ixo, iyo] = wbilerpg(x, y, xa, ya, xb, yb)
% WBILERPG - Weighted bilinear interpolation weights (GPU/OpenCL-enabled)
%
% [cxy, ixo, iyo] = WBILERPG(x, y, xa, ya, xb, yb) takes in a pair of grid
% vectors x, y and an array of pairs of endpoints (xa,ya) to (xb,yb) and
% returns the interpolation weights cxy, the x-indices ixo, and the
% y-indices iyo that describe the bi-linear inteprolation weights for each
% segment of the line from (xa,xb) to (xb,yb) as it intersects the x-grid
% and y-grid and their indices on the x-grid and y-grid. The arrays xa, ya,
% xb, yb must all be the same size.
%
% Each output is size [4 x (X + Y + 1)] x size(xa, 1:ndims(xa)) where X and
% Y are the length of the x and y vectors. The indices ixo and iyo are
% 1-based. If the index is invalid, ixo and iyo are 0. Multiple idenitcal
% indices represent contributions from different line segments intersecting
% the same grid index. These can be added afterwards to form the full
% weights.
%
% Note: This function requires that either a CUDA-enabled gpu or a working
% implementation of OpenCL via Matlab-OpenCL be available.
% 
% The following example shows how a sparse matrix can be generated by
% implicitly adding overlapping pixel weights.
%
% Example:
% % Create a grid
% [x,  y ] = deal(single(-5:5), single(-5:5)); % 11 x 11 grid
% [xa, ya] = deal(-4, +1);
% [xb, yb] = deal(+3, -2);
%
% % Get the interpolation weights
% [cxy, ixo, iyo] = wbilerpg(x, y, xa, ya, xb, yb); % get the line segment weights
%
% % Create a sparse matrix, implicitly summing weights from neighboring
% % line segments
% val = (ixo ~= 0) & (iyo ~= 0); % filter out invalid indices
% s = sparse(ixo(val), iyo(val), double(cxy(val)), numel(x), numel(y));
%
% figure;
% pcolor(x, y, full(s)')
% title("Weights from ("+xa+","+ya+"), to ("+xb+","+yb+").");
%
% See also XIAOLINWU_K_SCALED SPARSE WBILERP

arguments
    x (:,1) {mustBeReal, mustBeNumeric, mustBeFloat}
    y (:,1) {mustBeReal, mustBeNumeric, mustBeFloat}
    xa      {mustBeReal, mustBeNumeric, mustBeFloat}
    ya      {mustBeReal, mustBeNumeric, mustBeFloat}
    xb      {mustBeReal, mustBeNumeric, mustBeFloat}
    yb      {mustBeReal, mustBeNumeric, mustBeFloat}
end

% ensure floating point, sorted, grid in vector form
assert(issorted(x), 'x-grid vector must be sorted.');
assert(issorted(y), 'y-grid vector must be sorted.');
assert(numel(unique(cellfun(@ndims, {xa,ya,xb,yb}))) == 1, 'All end-point coordinates must have the same number of dimensions.')
assert(~any(diff(cell2mat(cellfun(@(x){size(x)'}, {xa,ya,xb,yb})),1,2),'all'), 'All end-point coordinates must have the same size.')

% move to same class to avoid precision matching issues
proto = cat(1,x(:),y(:),xa(:),ya(:),xb(:),yb(:)); % imply MATLAB casting rules
[x,y,xa,ya,xb,yb] = deal6fun(@(x)cast(x, 'like', proto),x,y,xa,ya,xb,yb);

% get the transforms that should be applied for each set of points
[yneg, steep, reverse] = arrayfun(@getTrans, xa, ya, xb, yb);

% pre-allocate final output
Ia = numel(xa); % number of point pairs
N = numel(x) + numel(y) + 1; % number of grid points
[ixo, iyo] = deal(zeros([4*N,Ia], 'int32'));
[cxy]      = deal(zeros([4*N,Ia], 'like', xa));

% determine the suffix based on the type
uclass = class(xa);
if uclass == "gpuArray", uclass = classUnderlying(xa); end
switch uclass
    case "double",prc = 64; suffix = "";
    case "single",prc = 32; suffix = "f";
    case "halfT", prc = 16; suffix = "h"; cxy = alias(cxy); % ensure aliased - we can index directly
end

% parse device
use_gdev = logical(gpuDeviceCount());
use_odev = exist('oclDevice','file') && ~isempty(oclDevice());

% specify the kernel (must be on the path)
if use_gdev
    % reference kernel
    kern = parallel.gpu.CUDAKernel('wbilerp.ptx', 'wbilerp.cu', "wbilerp" + suffix);
elseif use_odev
    % reference kernel
    kern = oclKernel('wbilerp.cl');

    % specify aliased types
    kern.defineTypes({uclass});
    kern.macros(end+1) = "QUPS_PRECISION="+prc;

    % validate precision support
    if   (uclass == "double") && (~kern.Device.SupportsDouble) ...
            || (uclass == "halfT") && (~kern.Device.SupportsHalf)
        error("QUPS:wbilerpg:precisionNotSupported", ...
            "Device " + kern.Device.Index + " (" + kern.Device.Name + ") " + ...
            "does not support " + uclass + " precision." ...
            );
    end
else
    % no kernel device found
    error("QUPS:wbilerpg:supportedDeviceNotFound", ...
        "wbilerpg() requires either a supported CUDA enabled GPU " + ...
        "or a working OpenCL implementation via Matlab-OpenCL. Use wbilerp instead." ...
        );
end

% proceed by which transform should be applied
for ineg = [false, true], for isteep = [false, true], for irev = [false, true]

            % indices matching this tranform
            ind = yneg == ineg & isteep == steep & irev == reverse;
            I = nnz(ind);

            % if no data follows this transform, skip this batch
            if I == 0, continue; end

            % transform: sort coordinates and endpoints
            [ux, uy, vx, vy, xg, yg] = applyTrans(xa(ind), ya(ind), xb(ind), yb(ind), x, y, ineg, isteep, irev);

            % now, we have ux <= vx, |dy| <= |dx|, 0 <= dy/dx <= 1
            % get the gradient
            m  = ((vy - uy) ./ (vx - ux));

            % get the inverse gradient
            mi = ((vx - ux) ./ (vy - uy));
            mi(vy == uy) = nan;

            % min/max values supported on the grid/line
            pml = complex(max(xg(1  ), ux), max(yg(1  ), uy)); % lower bound (1 x I)
            pmu = complex(min(xg(end), vx), min(yg(end), vy)); % upper bound (1 x I)

            % sort in x, then y, so that we have a non-descreasing line
            [ux, uy, vx, vy, m, mi] = dealfun(@(x) shiftdim(x(:), -2), ux, uy, vx, vy, m, mi); % move to 1 x 1 x I

            % all points ([N+1] x 2 x I)
            pall = [...
                ux, uy; ... endpoint
                vx, vy; ... endpoint
                [xg + 0*uy, uy + m  .* (xg - ux)]; ...  x-intercepts
                [ux + mi .* (yg - uy), yg + 0*uy]; ...  y-intercepts
                ];

            % sort and reshape them -> (2 x [N+1] x I)
            parfor (i = 1:I, 0), pall(:,:,i) = sortpoints(pall(:,:,i), m(i)); end
            pall = pagetranspose(pall);
            pall = complex(pall(1,:,:), pall(2,:,:)); % typecast

            % input/output sizing
            X = int32(numel(xg));
            Y = int32(numel(yg));
            % N = X + Y + 1;

            % preallocate output: each line segment produces 4 integrals for 4 grid
            % points defined by [[ix, iy, c1]; [ix+1, iy, c2]; [ix, iy+1, c3], [ix+1, iy+1, c4]];
            cxyo = zeros([4*N,I], 'like', real(pall));
            ixyo = -ones([4*N,I] , 'int32');
            ixyo = complex(ixyo, ixyo); % alias (x,y) -> (real, imag)

            % setup the execution size
            kern.ThreadBlockSize(1) = min(I,kern.MaxThreadsPerBlock);
            kern.GridSize = [ceil(I / kern.ThreadBlockSize(1)), 1, 1];

            % run the kernel
            if suffix ~= "h"
                [ixyo, cxyo] = kern.feval(ixyo, cxyo, pall, xg, yg, X, Y, I, pml, pmu);
            else
                [cxyo, pall, xg, yg, pml, pmu] = dealfun(@alias, cxyo, pall, xg, yg, pml, pmu);
                [ixyo, cxyo] = kern.feval( ...
                    ixyo, cxyo.val, pall.val, ...
                    xg.val, yg.val, X, Y, I, ...
                    pml.val, pmu.val ...
                    );
            end

            % set correct output for x and y in original coordinates
            [ixo(:,ind), iyo(:,ind)] = unapplyTrans(real(ixyo), imag(ixyo), ineg, isteep, Y);
            if suffix ~= "h", cxy(:,ind) = cxyo; % store normally
            else,             cxy.val(:,ind) = cxyo; % store while aliased
            end

end, end, end

% set output sizing as a vector in dim1
osz = [4*N, size(xa, 1:ndims(xa))];
[ixo, iyo, cxy] = deal3(reshape(ixo,osz), reshape(iyo,osz), reshape(cxy,osz));
[ixo, iyo] = deal(1+ixo, 1+iyo); % use 1-based indexing for MATLAB

end

% helper functions
function [a,b] = deal2(a,b), end
function [a,b,c] = deal3(a,b,c), end
function [a,b,c,d,e,f] = deal6(a,b,c,d,e,f), end
function [a,b,c,d,e,f] = deal6fun(fun,a,b,c,d,e,f)
a = fun(a); b = fun(b); c = fun(c); d = fun(d); e = fun(e); f = fun(f);
end

function pall = sortpoints(pall, m)

% sort in x, then y, so that we have a non-descreasing line
[pall, ~] = sortrows(pall, [1, 2], 'ascend'); % sort in x, then y ([N+1] x 2)

% when points are very close but not equal, numerical instability can cause
% things to be non-monotonic: enforce this by sorting y separately from x
% unless m = 0 / mi = nan. This swaps y-values when they are mismatched due
% to numerical instability.
if ~(m == 0), pall(:,2) = sort(pall(:,2), 'ascend'); end

end

function [yneg, steep, reverse] = getTrans(xa, ya, xb, yb)
% get coordinate transformation for this set of points

% if slope is negative, we negate y
yneg = (((yb - ya) / (xb - xa)) < 0) || (((xb - xa) / (yb - ya)) < 0);

% whether to swap x/y axis
steep = abs(yb - ya) > abs(xb - xa);

% whether to swap a/b order
if steep, reverse = ya > yb; else, reverse = xa > xb; end
end

function [ux, uy, vx, vy, xg, yg] = applyTrans(xa, ya, xb, yb, x, y, yneg, steep, reverse)
% apply coordinate transformations to this set of points

% sort coordinates and endpoints
if yneg
    if      steep &&  reverse
        [ux, uy, vx, vy, xg, yg] = deal6(yb, -xb, ya, -xa, y, flip(-x));
    elseif  steep && ~reverse
        [ux, uy, vx, vy, xg, yg] = deal6(ya, -xa, yb, -xb, y, flip(-x));
    elseif ~steep &&  reverse
        [ux, uy, vx, vy, xg, yg] = deal6(xb, -yb, xa, -ya, x, flip(-y));
    else % ~steep && ~reverse
        [ux, uy, vx, vy, xg, yg] = deal6(xa, -ya, xb, -yb, x, flip(-y));
    end
else
    if      steep &&  reverse
        [ux, uy, vx, vy, xg, yg] = deal6(yb, xb, ya, xa, y, x);
    elseif  steep && ~reverse
        [ux, uy, vx, vy, xg, yg] = deal6(ya, xa, yb, xb, y, x);
    elseif ~steep &&  reverse
        [ux, uy, vx, vy, xg, yg] = deal6(xb, yb, xa, ya, x, y);
    else % ~steep && ~reverse
        [ux, uy, vx, vy, xg, yg] = deal6(xa, ya, xb, yb, x, y);
    end
end

end

function [ixo, iyo] = unapplyTrans(ixo, iyo, yneg, steep, Y)
% set correct output for x and y in original coordinates
if yneg, j = iyo > 0; iyo(j) = (Y - 1) - iyo(j); end
if steep, [ixo, iyo] = deal2(iyo, ixo); end

end


